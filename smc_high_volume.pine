//@version=5
indicator("SMC Detector - HIGH VOLUME MARKETS", shorttitle="SMC-HV", overlay=true)

// === CONFIGURATION - AUTOMATIQUE ===
webhook_url = input.string("https://smc-gal.onrender.com/tv", "Webhook URL")

// Volume filter for high-activity markets only
min_volume_mult = input.float(1.5, "Minimum Volume Multiplier", minval=1.0, maxval=5.0)

// === SYMBOL LOGIC - D√âTECTION AUTOMATIQUE DU GRAPHIQUE ===
get_symbol_data() =>
    // Nettoie le ticker pour avoir seulement BTCUSDT.P (sans BYBIT:)
    raw_symbol = syminfo.tickerid
    current_symbol = str.replace(raw_symbol, "BYBIT:", "")
    current_symbol := str.replace(current_symbol, "BINANCE:", "")
    
    asset_type = "crypto"
    
    if str.contains(current_symbol, "BTC") or str.contains(current_symbol, "ETH") or str.contains(current_symbol, "USDT")
        asset_type := "crypto"
    else if str.contains(current_symbol, "XAU")
        asset_type := "gold"
    
    [current_symbol, asset_type]

[symbol_select, asset_type] = get_symbol_data()

// === HIGH VOLUME FILTER ===
volume_sma = ta.sma(volume, 20)
high_volume = volume > volume_sma * 1.0  // TEST: Lowered from 1.5x to 1.0x for more signals

// === SMC DETECTION ENHANCED ===
// ATR calculation with asset-specific adjustments
atr_length = 14
atr_value = ta.atr(atr_length)

// Volume-weighted ATR for better accuracy
vol_weighted_atr = atr_value * (volume / volume_sma)

// POI (Point of Interest) detection - Enhanced for high volume
rsi_value = ta.rsi(close, 14)
poi_valid = (ta.crossover(rsi_value, 30) or ta.crossunder(rsi_value, 70))  // TEST: Removed high_volume requirement

// FVG (Fair Value Gap) detection - More strict for perpetuals
fvg_threshold = asset_type == "crypto" ? 0.5 : 0.3  // TEST: Lowered from 0.8/0.5 to 0.5/0.3
fvg_gap = math.abs(high[1] - low[1]) > atr_value * fvg_threshold
fvg_open = fvg_gap and (close > high[1] or close < low[1])  // TEST: Removed high_volume requirement

// Order Block detection - Volume confirmation required
ob_volume_threshold = asset_type == "crypto" ? 2.0 : 1.5
ob_volume = volume > ta.sma(volume, 20) * ob_volume_threshold
ema_cross = ta.crossover(close, ta.ema(close, 20)) or ta.crossunder(close, ta.ema(close, 20))
ob_valid = ob_volume and ema_cross

// BOS (Break of Structure) - Enhanced for volatile markets
swing_length = asset_type == "crypto" ? 7 : 5
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)
bos_detected = not na(swing_high) or not na(swing_low)
bos_confirm = bos_detected and high_volume

// CHOCH (Change of Character) - Trend reversal detection
ema_fast = ta.ema(close, 21)
ema_slow = ta.ema(close, 50)
trend_direction = ema_fast > ema_slow ? 1 : -1
choch_confirm = trend_direction != trend_direction[1] and high_volume

// Additional SMC flags for high volume markets
liq_swept = volume > ta.sma(volume, 10) * 2.5 and high_volume
imbalance_threshold = asset_type == "crypto" ? 1.2 : 0.8
imbalance_filled = math.abs(close - open) > atr_value * imbalance_threshold

// Trend alignment - Multiple timeframes
ema_200 = ta.ema(close, 200)
trend_aligned = (close > ema_fast and ema_fast > ema_slow and ema_slow > ema_200) or (close < ema_fast and ema_fast < ema_slow and ema_slow < ema_200)

volume_confirm = volume > ta.sma(volume, 20) * 1.3

// Time filter - Avoid low liquidity hours (enhanced for crypto)
is_crypto = asset_type == "crypto"
avoid_hours = is_crypto ? false : (hour >= 22 or hour <= 2)
time_filter = not avoid_hours and high_volume

// === SIGNAL GENERATION - BALANCED APPROACH ===
// Strat√©gie simplifi√©e mais efficace (comme OPAL bot)
// Minimum 4 crit√®res de base + trend confirmation
long_signal_strength = (poi_valid or fvg_open) and trend_aligned and volume_confirm
short_signal_strength = (poi_valid or fvg_open) and trend_aligned and volume_confirm

long_condition = long_signal_strength and close > ema_fast and high_volume
short_condition = short_signal_strength and close < ema_fast and high_volume

// === WEBHOOK PAYLOAD - PINE CALCULE TOUT ===
if (long_condition or short_condition)
    direction = long_condition ? "LONG" : "SHORT"
    
    // EVENT ID UNIQUE PAR BOUGIE (√©vite doublons)
    bar_time = str.tostring(time)
    event_id = symbol_select + "_" + bar_time + "_" + direction
    
    // PINE SCRIPT CALCULE SL/TP (pas le bot Python)
    final_atr = asset_type == "crypto" ? vol_weighted_atr : atr_value
    
    entry_price = close
    stop_loss = direction == "LONG" ? entry_price - (final_atr * 2.5) : entry_price + (final_atr * 2.5)
    take_profit = direction == "LONG" ? entry_price + (final_atr * 4.0) : entry_price - (final_atr * 4.0)
    
    // D√âTECTION AUTOMATIQUE DU TIMEFRAME DU GRAPHIQUE
    current_tf = timeframe.period
    
    // JSON COMPLET - Tout est calcul√© ici avec timeframe ET TOUS LES FLAGS
    payload = '{"event_id":"' + event_id + '","symbol":"' + symbol_select + '","timeframe":"' + current_tf + '","direction":"' + direction + '","entry":' + str.tostring(entry_price) + ',"sl":' + str.tostring(stop_loss) + ',"tp":' + str.tostring(take_profit) + ',"atr":' + str.tostring(final_atr) + ',"poi_valid":' + str.tostring(poi_valid) + ',"fvg_open":' + str.tostring(fvg_open) + ',"ob_valid":' + str.tostring(ob_valid) + ',"bos_confirm":' + str.tostring(bos_confirm) + ',"choch_confirm":' + str.tostring(choch_confirm) + ',"liq_swept":' + str.tostring(liq_swept) + ',"imbalance_filled":' + str.tostring(imbalance_filled) + ',"trend_aligned":' + str.tostring(trend_aligned) + ',"volume_confirm":' + str.tostring(volume_confirm) + ',"time_filter":' + str.tostring(time_filter) + '}'
    
    alert(payload, alert.freq_once_per_bar)

// === CALCUL CONFLUENCE SCORE (m√™me logique que Python) ===
flag_count = (poi_valid ? 1 : 0) + (fvg_open ? 1 : 0) + (ob_valid ? 1 : 0) + (bos_confirm ? 1 : 0) + (choch_confirm ? 1 : 0) + (liq_swept ? 1 : 0) + (imbalance_filled ? 1 : 0) + (trend_aligned ? 1 : 0) + (volume_confirm ? 1 : 0) + (time_filter ? 1 : 0)
confluence_score = (flag_count / 10.0) * 100

// SEUIL 80% - Ne montre les fl√®ches QUE si confluence ‚â• 80%
show_signal = confluence_score >= 80.0

// === üé® PROFESSIONAL UI - STYLE OPAL ===

// Alertes avec texte clair + score de confluence
alert_text_long = "SMC-HV - LONG ENTRY (" + str.tostring(confluence_score, "#") + "%)\n" + symbol_select + ", " + timeframe.period + " ‚Ä¢ " + str.format("{0,time,HH:mm:ss}", time)
alert_text_short = "SMC-HV - SHORT ENTRY (" + str.tostring(confluence_score, "#") + "%)\n" + symbol_select + ", " + timeframe.period + " ‚Ä¢ " + str.format("{0,time,HH:mm:ss}", time)

// Fl√®ches UNIQUEMENT si confluence ‚â• 80%
plotshape(long_condition and show_signal, style=shape.triangleup, location=location.belowbar, 
          color=color.new(color.lime, 0), size=size.small, title="LONG", text="L")
plotshape(short_condition and show_signal, style=shape.triangledown, location=location.abovebar, 
          color=color.new(color.red, 0), size=size.small, title="SHORT", text="S")

// 2Ô∏è‚É£ Pas de boxes - Trop encombrant, on garde juste les fl√®ches

// 3Ô∏è‚É£ EMAs - Lignes simples
plot(ema_fast, "EMA 21", color=color.new(color.aqua, 70), linewidth=1)
plot(ema_slow, "EMA 50", color=color.new(color.orange, 70), linewidth=1)