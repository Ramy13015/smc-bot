//@version=5
indicator("SMC Detector - QUALITY (70%)", shorttitle="SMC-Q70", overlay=true)

// === CONFIGURATION - VERSION SOUPLE POUR VOIR DES SIGNAUX ===
webhook_url = input.string("https://smc-gal.onrender.com/tv", "Webhook URL")

// Volume filter - ABAISSÉ pour plus de signaux
min_volume_mult = input.float(0.8, "Minimum Volume Multiplier", minval=0.5, maxval=2.0)

// SEUIL DE CONFLUENCE RÉGLABLE
confluence_threshold = input.float(70.0, "Confluence Threshold (%)", minval=20.0, maxval=100.0, step=10.0)

// === SYMBOL LOGIC - DÉTECTION AUTOMATIQUE DU GRAPHIQUE ===
get_symbol_data() =>
    raw_symbol = syminfo.tickerid
    current_symbol = str.replace(raw_symbol, "BYBIT:", "")
    current_symbol := str.replace(current_symbol, "BINANCE:", "")
    
    asset_type = "crypto"
    
    if str.contains(current_symbol, "BTC") or str.contains(current_symbol, "ETH") or str.contains(current_symbol, "USDT")
        asset_type := "crypto"
    else if str.contains(current_symbol, "XAU")
        asset_type := "gold"
    
    [current_symbol, asset_type]

[symbol_select, asset_type] = get_symbol_data()

// === HIGH VOLUME FILTER - ABAISSÉ ===
volume_sma = ta.sma(volume, 20)
high_volume = volume > volume_sma * 0.8  // ABAISSÉ de 1.0 à 0.8

// === SMC DETECTION - SIMPLIFIÉ ===
atr_length = 14
atr_value = ta.atr(atr_length)
vol_weighted_atr = atr_value * (volume / volume_sma)

// POI - SIMPLIFIÉ
rsi_value = ta.rsi(close, 14)
poi_valid = (ta.crossover(rsi_value, 35) or ta.crossunder(rsi_value, 65))  // ÉLARGI de 30/70 à 35/65

// FVG - SEUIL ABAISSÉ
fvg_threshold = asset_type == "crypto" ? 0.3 : 0.2  // ABAISSÉ
fvg_gap = math.abs(high[1] - low[1]) > atr_value * fvg_threshold
fvg_open = fvg_gap and (close > high[1] or close < low[1])

// Order Block - SEUIL ABAISSÉ
ob_volume_threshold = asset_type == "crypto" ? 1.5 : 1.2  // ABAISSÉ
ob_volume = volume > ta.sma(volume, 20) * ob_volume_threshold
ema_cross = ta.crossover(close, ta.ema(close, 20)) or ta.crossunder(close, ta.ema(close, 20))
ob_valid = ob_volume and ema_cross

// === AJOUT : OB MITIGATION - Vérifier que l'OB est traversé ===
var float ob_high = na
var float ob_low = na
var bool ob_mitigated = false

if ob_valid
    ob_high := high[1]
    ob_low := low[1]
    ob_mitigated := (close > ob_high) or (close < ob_low)
else
    ob_mitigated := false

// === ANTI-PIÈGE : FILTRES PROFESSIONNELS (VERSION INTELLIGENTE) ===
// 1. FAUX BREAKOUT - Rejeter les breakouts minuscules
recent_high = ta.highest(high, 20)
recent_low = ta.lowest(low, 20)
is_fake_breakout_long = close > recent_high and close < recent_high * 1.003  // <0.3%
is_fake_breakout_short = close < recent_low and close > recent_low * 0.997

// 2. NIVEAUX RONDS - Éviter les zones de liquidation psychologiques
price_mod_1000 = close % 1000
price_mod_500 = close % 500
near_round_level = (price_mod_1000 < 20 or price_mod_1000 > 980) or (price_mod_500 < 10 or price_mod_500 > 490)

// 3. STOP HUNT - Détecter les mèches de liquidation
wick_size_upper = high - math.max(open, close)
wick_size_lower = math.min(open, close) - low
body_size = math.abs(close - open)
is_stop_hunt = (wick_size_upper > body_size * 2.5) or (wick_size_lower > body_size * 2.5)

// 4. RANGE TRADING - Éviter les consolidations
atr_ratio = atr_value / close
is_low_volatility = atr_ratio < 0.008  // <0.8%

// SCORE ANTI-PIÈGE (au lieu de tout bloquer, on compte les drapeaux rouges)
trap_score = (is_fake_breakout_long or is_fake_breakout_short ? 1 : 0) + (near_round_level ? 1 : 0) + (is_stop_hunt ? 1 : 0) + (is_low_volatility ? 1 : 0)
// Si 2 drapeaux rouges ou plus = probablement un piège
is_likely_trap = trap_score >= 2

// BOS - SIMPLIFIÉ
swing_length = asset_type == "crypto" ? 5 : 3  // RÉDUIT
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)
bos_detected = not na(swing_high) or not na(swing_low)
bos_confirm = bos_detected  // Enlevé high_volume requirement

// CHOCH
ema_fast = ta.ema(close, 21)
ema_slow = ta.ema(close, 50)
trend_direction = ema_fast > ema_slow ? 1 : -1
choch_confirm = trend_direction != trend_direction[1]  // Enlevé high_volume

// Autres flags - SIMPLIFIÉS
liq_swept = volume > ta.sma(volume, 10) * 2.0  // ABAISSÉ et sans high_volume
imbalance_threshold = asset_type == "crypto" ? 0.8 : 0.5  // ABAISSÉ
imbalance_filled = math.abs(close - open) > atr_value * imbalance_threshold

// Trend alignment - VERSION PERMISSIVE (juste la direction de base)
ema_200 = ta.ema(close, 200)
trend_aligned = ema_fast != ema_slow  // Toujours vrai sauf si exactement égal (impossible)

volume_confirm = volume > ta.sma(volume, 20) * 0.9  // ABAISSÉ

// Time filter - PLUS PERMISSIF
is_crypto = asset_type == "crypto"
avoid_hours = is_crypto ? false : (hour >= 23 or hour <= 1)  // RÉDUIT
time_filter = not avoid_hours  // Sans high_volume requirement

// === SIGNAL GENERATION - VERSION STRICTE ANTI-FAUX SIGNAUX ===
// Conditions de base
long_signal_strength = (poi_valid or fvg_open or ob_valid) and volume_confirm
short_signal_strength = (poi_valid or fvg_open or ob_valid) and volume_confirm

// FILTRE FINAL - Version INTELLIGENTE avec protection anti-piège
// Niveau 1: Signal de base + Direction
basic_long = long_signal_strength and close > ema_fast
basic_short = short_signal_strength and close < ema_fast

// Niveau 2: Ajouter protection si OB détecté (OB = zone dangereuse)
ob_protection_long = ob_valid ? ob_mitigated : true  // Si OB existe, exiger mitigation
ob_protection_short = ob_valid ? ob_mitigated : true

// Niveau 3: Filtrer les pièges évidents
valid_long = basic_long and ob_protection_long and high_volume and not is_likely_trap
valid_short = basic_short and ob_protection_short and high_volume and not is_likely_trap

// Compatibilité avec le reste du code
long_condition = valid_long
short_condition = valid_short

// === CALCUL CONFLUENCE SCORE ===
flag_count = (poi_valid ? 1 : 0) + (fvg_open ? 1 : 0) + (ob_valid ? 1 : 0) + (bos_confirm ? 1 : 0) + (choch_confirm ? 1 : 0) + (liq_swept ? 1 : 0) + (imbalance_filled ? 1 : 0) + (trend_aligned ? 1 : 0) + (volume_confirm ? 1 : 0) + (time_filter ? 1 : 0)
confluence_score = (flag_count / 10.0) * 100

// SEUIL RÉGLABLE (par défaut 70%)
show_signal = confluence_score >= confluence_threshold

// === WEBHOOK PAYLOAD ===
if (long_condition or short_condition) and show_signal
    direction = long_condition ? "LONG" : "SHORT"
    bar_time = str.tostring(time)
    event_id = symbol_select + "_" + bar_time + "_" + direction
    
    final_atr = asset_type == "crypto" ? vol_weighted_atr : atr_value
    entry_price = close
    stop_loss = direction == "LONG" ? entry_price - (final_atr * 2.5) : entry_price + (final_atr * 2.5)
    take_profit = direction == "LONG" ? entry_price + (final_atr * 4.0) : entry_price - (final_atr * 4.0)
    current_tf = timeframe.period
    
    payload = '{"event_id":"' + event_id + '","symbol":"' + symbol_select + '","timeframe":"' + current_tf + '","direction":"' + direction + '","entry":' + str.tostring(entry_price) + ',"sl":' + str.tostring(stop_loss) + ',"tp":' + str.tostring(take_profit) + ',"atr":' + str.tostring(final_atr) + ',"poi_valid":' + str.tostring(poi_valid) + ',"fvg_open":' + str.tostring(fvg_open) + ',"ob_valid":' + str.tostring(ob_valid) + ',"bos_confirm":' + str.tostring(bos_confirm) + ',"choch_confirm":' + str.tostring(choch_confirm) + ',"liq_swept":' + str.tostring(liq_swept) + ',"imbalance_filled":' + str.tostring(imbalance_filled) + ',"trend_aligned":' + str.tostring(trend_aligned) + ',"volume_confirm":' + str.tostring(volume_confirm) + ',"time_filter":' + str.tostring(time_filter) + '}'
    
    alert(payload, alert.freq_once_per_bar)

// === UI ===
// Labels pour montrer le score de confluence UNIQUEMENT si ≥ 70%
label_text = (long_condition or short_condition) and show_signal ? str.tostring(confluence_score, "#") + "%" : na
label_color = confluence_score >= 80 ? color.new(color.green, 0) : 
              color.new(color.orange, 0)  // 70-79% = Orange, 80%+ = Vert

// Afficher score UNIQUEMENT si confluence ≥ 70% (= show_signal)
if (long_condition or short_condition) and show_signal
    label.new(bar_index, high, label_text, 
              style=label.style_label_down, 
              color=label_color, 
              textcolor=color.white, 
              size=size.small)

// Flèches UNIQUEMENT si confluence ≥ 70%
direction_emoji = long_condition ? "▲" : "▼"
plotshape(long_condition and show_signal, style=shape.triangleup, location=location.belowbar, 
          color=color.new(color.lime, 0), size=size.normal, title="LONG", text="L")
plotshape(short_condition and show_signal, style=shape.triangledown, location=location.abovebar, 
          color=color.new(color.red, 0), size=size.normal, title="SHORT", text="S")

// EMAs
plot(ema_fast, "EMA 21", color=color.new(color.aqua, 50), linewidth=2)
plot(ema_slow, "EMA 50", color=color.new(color.orange, 50), linewidth=2)
plot(ema_200, "EMA 200", color=color.new(color.gray, 70), linewidth=1)

// Afficher la confluence en temps réel
var table info_table = table.new(position.top_right, 2, 6, bgcolor=color.new(color.black, 80), border_width=1)
if barstate.islast
    table.cell(info_table, 0, 0, "Confluence", text_color=color.white)
    table.cell(info_table, 1, 0, str.tostring(confluence_score, "#") + "%", 
               text_color=confluence_score >= confluence_threshold ? color.lime : color.orange)
    
    table.cell(info_table, 0, 1, "Seuil", text_color=color.white)
    table.cell(info_table, 1, 1, str.tostring(confluence_threshold, "#") + "%", text_color=color.white)
    
    table.cell(info_table, 0, 2, "Flags actifs", text_color=color.white)
    table.cell(info_table, 1, 2, str.tostring(flag_count) + "/10", 
               text_color=flag_count >= 8 ? color.lime : flag_count >= 5 ? color.orange : color.red)
    
    table.cell(info_table, 0, 3, "Volume", text_color=color.white)
    table.cell(info_table, 1, 3, high_volume ? "✅" : "❌", text_color=high_volume ? color.lime : color.red)
    
    table.cell(info_table, 0, 4, "Trend", text_color=color.white)
    table.cell(info_table, 1, 4, trend_aligned ? "✅" : "❌", text_color=trend_aligned ? color.lime : color.red)
    
    table.cell(info_table, 0, 5, "Symbol", text_color=color.white)
    table.cell(info_table, 1, 5, symbol_select, text_color=color.yellow)
